\begin{theorem}
    Następujące stwierdzenia są równoważne dla dowolnego języka \( L \subset \Sigma^*\):
    \begin{enumerate}
        \item Istnieje deterministyczna Maszyna Turinga M taka, że \(L(M) = L\).
        \item Istnieje niedeterministyczna Maszyna Turinga N taka, że \(L(N) = L \). 
    \end{enumerate}
\end{theorem}

\begin{proof}
    Dowód faktu, że mając deterministyczną Maszynę Turinga możemy utworzyć niedeterministyczną Maszynę Turinga jest trywialny, ponieważ każda funkcja jest relacją. 
    
    Mając daną niedeterministyczną Maszynę Turinga \(N\), chcemy stworzyć równoważną deterministyczną Maszynę Turinga \(M\). Intuicyjnie rozwiązanie polega na tym, żeby chodzić BFS-em po nieskończonym grafie konfiguracji maszyny \(N\).
    
    Alfabet rozszerzamy o separator, używany do rozdzielania kolejnych konfiguracji ,,w kolejce''. 
    
    Początkowo ,,w kolejce'' konfiguracji znajduje się jedynie konfiguracja startowa. Mając głowicę w jakimś położeniu, znając jej stan i to co jest ,,na prawo'' od niej, dopisujemy do kolejki symbol separacji, a następnie całą konfigurację po wykonaniu któregoś z przejść \(N\). Procedurę tę wykonujemy dla każdego możliwego przejścia z \(N\). 
    Dla każdej sytuacji dozwolonych przejść jest skończenie wiele, więc zakodowanie tego jest możliwe.
    
    Następnym krokiem symulacji jest przejście do kolejnej konfiguracji z kolejki tak jak w przeglądzie BFS.
    Za każdym razem, gdy analizujemy konfigurację, sprawdzamy czy zapisany w niej stan jest akceptujący. Jeśli tak, to akceptujemy słowo. Jeśli nie ma zdefiniowanych przejść dla określonej sytuacji, to nie robimy nic i przechodzimy do kolejnej konfiguracji w kolejce.
    
    Ważne, że symulacja działa na zasadzie BFS a nie DFS, ponieważ wtedy mogłaby zapętlić się na jakiejś ścieżce i nigdy nie trafić do stanu akceptujacego dla słowa, które powinno zostać zaakceptowane.
    W opisanej powyżej wersji symulujemy po jednym kroku z każdej możliwej ścieżki po kolei.
\end{proof}
