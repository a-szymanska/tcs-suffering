Dla danych \( a, b > 0 \) algorytm zwraca \( d = \gcd(a,b) \) oraz liczby całkowite \( s \) i \( t \), które spełniają \( d = s\cdot a + t\cdot b \).

\begin{greyframe}
    Algorytm:
    \begin{enumerate}
        \item Jeśli \( a < b \), zamień \( a \) i \( b \).
        \item Jeśli \( b = 0 \), zwróć \( d = a \) oraz parę \( (1,0) \).
        \item Podziel z resztą \( a \) przez \( b \), otrzymując \( a = q \cdot b + r \).
        \item Wywołaj \( \gcd(b,r) \), otrzymując \( d \) oraz parę \( (s', t') \) taką, że \( s'\cdot b + t' \cdot r = d \).
        \item Zwróć \( d \) oraz parę \( (t', s' - q \cdot t') \).
    \end{enumerate}
\end{greyframe}

\vspace{1em}\noindent
\textit{Algorytm zwraca poprawne \( d = \gcd(a, b) \).}
\begin{proof}
    Wystarczy pokazać, że \( \gcd(a, b) = \gcd(b, r) \), jeśli \( a = q \cdot b + r \). Niech \( d = \gcd(a, b) \).
    \[
        a = 0 \pmod{d}
    \]
    \[
        b = 0 \pmod{d}
    \]
    \[
        r = a - q \cdot b = 0 \pmod{d}
    \]
\end{proof}
\textit{Algorytm zwraca poprawne \( (s, t) \).}
\begin{proof}
    Z tożsamości B\'ezout wiemy, że
    \[
        \forall_{a, b \not= 0 } \ \exists_{s, t} \ a \cdot s + b \cdot t = \gcd(a, b)
    \]
    Jako krok bazowy sprawdzamy przypadek \( b = 0 \), rzeczywiście \( a \cdot 1 + 0 = \gcd(a, 0) \). \\
    Niech \( a = q \cdot b + r \). Korzystając z tego, że \( \gcd(a, b) = \gcd(b, r) = d \), otrzymujemy:
    \[
        b \cdot s' + r \cdot t' = d
    \]
    \[
        b \cdot s' + (a - q \cdot b) \cdot t' = d
    \]
    Przyrównując równania, otrzymujemy \( s = t', \ t = s' - q \cdot t' \), co było do pokazania.
\end{proof}

Własności algorytmu:
\begin{enumerate}
    \item Liczba iteracji: co najwyżej \( \log_{\varphi} a \), gdzie \( \varphi = \frac{1 + \sqrt{5}}{2} \)
    \item Złożoność: \( \bigO(\log^2 a) \)
    \item \( \abs{s} \leq b \), \( \abs{t} \leq a \)
\end{enumerate}
Ad 1. Dowiedzione na ćwiczeniach w pierwszym zestawie zadań. \\
Ad 2. Zauważmy, że przy każdym wywołaniu rekurencyjnym przynajmniej jeden z argumentów zmniejsza się o połowę: \\
Jeśli \( b \leq \frac{a}{2} \), to \( r < b < \frac{a}{2} \). \\
Jeśli \( b > \frac{a}{2} \), to \( r = a - b < \frac{a}{2} \). \\
Złożoność operacji w kroku rekursji  to \( \bigO(\log a) \), więc cały algorytm ma złożoność \( \bigO(\log^2 a) \).