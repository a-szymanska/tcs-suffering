Dla danych \( a,b > 0 \) algorytm zwraca \( \gcd(a,b) \), wykonując tylko odejmowanie i operacje binarne.

\begin{greyframe}
    Algorytm:
    \begin{enumerate}
    \item Jeśli \( a < b \), zamień \( a \) i \( b \).
    \item Jeśli \( 2 \mid a \) i \( 2 \nmid b \), zwróć \( gcd(a/2, b) \),
    \item Jeśli \( 2 \nmid a \) i \( 2 \mid b \), zwróć \( \gcd(a, b/2) \),
    \item Jeśli \( 2 \mid a \) i \( 2 \mid b \), zwróć \( 2 \cdot \gcd(a/2, b/2) \),
    \item Jeśli \( 2 \nmid a \) i \( 2 \nmid b \), zwróć \( \gcd(b, a - b) \).
    \end{enumerate}
\end{greyframe}

\vspace{1em}\noindent
Algorytm zwraca poprawne \( d = \gcd(a, b) \).
\begin{proof}
    Jeśli któryś z argumentów jest nieparzysty (przypadki 2 i 3), to \( 2 \nmid \gcd(a, b) \), dlatego możemy podzielić parzysty argument przez 2. \\
    Jeśli oba argumenty są parzyste (przypadek 4), to \( d = \gcd(a, b) \) też jest parzyste, ponieważ inaczej \( 2 \cdot d \) dzieliłoby obie liczby, co byłoby sprzecznością z tym, że \( d \) jest największym dzielnikiem. Dlatego możemy wydzielić 2 i obliczyć \( 2 \cdot \gcd(a/2, b/2) \). \\
    Jeśli obie liczby są nieparzyste, to obliczamy \( d = \gcd(b, a - b) \), które jest równe \( gcd(a, b) \), ponieważ:
    \[
        a \equiv 0 \ \mod \ d
    \]
    \[
        b \equiv 0 \ \mod \ d
    \]
    \[
        a - b \equiv 0 \ \mod \ d
    \]
\end{proof}

W każdym z przypadków od 2 do 4, co najmniej jeden z argumentów wywołania rekurencyjnego zmniejsza się o połowę. Takich wywołań może być więc co najwyżej logarytmicznie wiele.
Pozostaje do przeanalizowania przypadek 5. Ponieważ \( a \) i \( b \) są nieparzyste, to \( a - b \) jest parzyste, więc w kolejnym wywołaniu wykona się przypadek 2 lub 3. Czyli któryś z argumentów zmniejszy się o połowę w co najwyżej dwóch krokach.
To dowodzi złożoności \( \bigO(\log(a) \cdot M(a)) \), gdzie \( M(a) \) to koszt odejmowania i operacji bitowych, który jest liniowy od długości zapisu liczb.