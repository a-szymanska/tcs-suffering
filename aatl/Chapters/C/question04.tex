\subsection{Faktoryzacja przez liczby \( B \)-gładkie}
Dla ustalonego \( B \) definiujemy \( \{p_1, \dots, p_s\} \) zbiór wszystkich liczb pierwszych mniejszych od \( B \) oraz \(\pi(B) = s \). liczba \( B \)-gładka to taka, której wszystkie pierwsze dzielniki są mniejsze od \( B \).
    
Celem jest rozłożyć \( N \) na czynniki pierwsze. Wybieramy pewne \( a_1, \dots, a_k \), po czym obliczamy \( b_i = a_i^2 \pmod{N} \). Chcemy wziąć taki podzbiór \(b_i \), żeby iloczyn jego elementów był pełnym kwadratem.

\begin{lemma}
    W każdym zbiorze liczb B-gładkich o liczności większej od \( \pi(B) \) istnieje podzbiór, którego iloczyn jest kwadratem.
\end{lemma}
\begin{proof}
    Niech \( \{x_1, \dots, x_k\} \) będą liczbami \( B \)-gładkimi, gdzie \( k > s \). Rozkładamy każdą z nich na czynniki pierwsze:
    \[
        x_i = p_1^{\alpha_{1i}} \cdots p_s^{\alpha_{si}}
    \]
    Następnie każdej przypisujemy wektor:
    \[
        v_i = (\alpha_{1i} \text{ mod } 2, \dots, \alpha_{si} \text{ mod } 2)
    \]
    Jeśli dla pewnego podzbioru każdy czynnik \( p_i \) występuję parzyście wiele razy, czyli suma tego podzbioru modulo 2 jest wektorem zerowym, to jest poszukiwany pozdbiór, bo jego iloczyn jest kwadratem. Skoro \( k > s \), to wektory \( v_1, \dots, v_k \) są liniowo zależne w \( \integer_2^s \), więc taki podzbiór musi istnieć i można go znaleźć za pomocą eliminacji Gaussa w \( \bigO(s^3) \).
\end{proof}
Z takim wyposażeniem można podjąć się faktoryzacji \( N \).
\begin{greyframe}
    Algorytm faktoryzacji:
    \begin{enumerate}
        \item Znajdź takie \( a_1, \dots, a_k \), że \( a_i^2 \mod N \) nie ma dzielników pierwszych większych \\ niż \( B \).
        \item Dla każdego \( b_i = a_i^2 \) wyznacz wektor \( v_i \).
        \item Znajdź taki podzbiór \( I \subseteq \{1, \dots, k\} \), że wektory \( v_i,\; i \in I \) są liniowo zależne.
        \item Przypisz \( u = \prod_{i \in I}\; a_i \mod N \) oraz \( v = \sqrt{\prod_{i \in I}\; b_i} \mod N \)
        \item Jeśli \( u \neq \pm v \), to \( \gcd(u + v, N) \) jest nietrywialnym dzielnikiem \( N \), \\ ponieważ \( u^2 = v^2 \pmod{N} \).
        \item Jeśli \( u = \pm v \), to powtórz procedurę.
    \end{enumerate}
\end{greyframe}
Krok 1. jest na razie czarną skrzynką, ale można za nią podstawić algorytm sita kwadratowego.

\subsection{Sito kwadratowe}
Poszukiwane liczby \( a_i \) muszą być większe od \( \sqrt{N} \), więc sprawdzamy po kolei dla potencjalnych kandydatów, czy reszty są \( B \)-gładkie. Ustalmy pewną stałą \( K \). Dla \( i \in \{0, \dots, K-1\} \) definiujemy:
\[ X[i] = \left\lceil \sqrt{N} \right\rceil + i \]
\[ Y[i] = X[i]^2 \mod N = \left(\left\lceil \sqrt{N} \right\rceil + i\right) - N \]
Trzeba rozłożyć wszystkie \( Y[i] \) na czynniki - najlepiej na raz, poniższym algorytmem.
\begin{greyframe}
    Algorytm sita kwadratowego:
    \begin{enumerate}
        \item Dla każdego \( p < B \):
        \begin{enumerate}
            \item Usuń ze zbioru \( \{p_1, \dots, p_s\} \) te liczby, dla których \( X[j]^2 \neq N \pmod{p} \), \\ czyli \( Y[i] \neq 0 \pmod{p} \).
            \item Algorytmem Tonellego-Shanksa znajdź rozwiązanie \( X[i] = \pm k \) równania \\ \( X[i]^2 = N \pmod{p} \).
            \item Podziel przez \( p \) wszystkie \( Y[i] \), dla których \( X[j] = \pm k \pmod{p} \).
        \end{enumerate}
        \item Jeśli \( Y[i] \) zmaleje do 1, to początkowo musiało być liczbą \( B \)-gładką.
    \end{enumerate}
\end{greyframe}
Dodatkowe usprawnienie algorytmu polega na ominięciu dzielenia dużych liczb. Zamiast wartości \( Y[i] \) można przechowywać liczbę rzeczywistą \( Z[i] = \log Y[i] \). Wtedy dzielenie \( Y[i] \) przez \( p \) jest zastąpione przez odejmowanie \( \log p \) od \( Z[i] \). Warunkiem \( B \)-gładkości jest (prawie) wyzerowanie się \( Z[i] \).
Problemem może być występowanie czynników \( Y[i] \) z potęgą \( \alpha > 1 \). Należy wykryć to od razu liczby \( Y[i] \) podzielne przez \( p^{\alpha} \) dla każdego możliwego \( \alpha \), stosując tę samą metodę.

\textbf{Złożoność:} \\
Przy optymalnym wyborze parametrów - \( B,\; K \) rzędu \( e^{\sqrt{\ln N \ln\ln N}} \) - złożoność algorytmu to \( \bigO(e^{(1 + {\scriptscriptstyle\mathcal{O}}(1))\sqrt{\ln N \ln\ln N}}) \), czyli podwykładnicza.

\subsection{Metoda Multi Polynomial Quadratic Sieve (MPQS)}
Algorytm sita kwadratowego można zrównoleglić, używając wielu różnych wielomianów postaci \( (A \cdot X + B)^2 - N \) zamiast \( X^2 - N \).