Celem jest rozłożyć na czynniki liczbę złożoną \( n \). Załóżmy, że \( p \) jest jakimś jej dzielnikiem pierwszym oraz \( p \leq \sqrt{n} \). Wybieramy pewną łatwo obliczalną funkcję (wielomian niskiego stopnia), niech to będzie \( f(x) = x^2 + 1 \). Chcemy zbadać ciąg \( x_0 = 2,\; x_k = f(x_{k-1}) \mod \ n \). Zakładamy, że wartości będą się rozkładały równomiernie \( \mod \ n \). Można się spodziewać, że ciąg zapętli się po około \( \sqrt{n} \) krokach. Przypuszczamy jednak, że uda się zaobserwować to już wcześniej, po \( \sqrt{p} \) krokach. Jeśli uda się znaleźć \( x_i = x_j \mod \ p \), to \( \gcd(x_i - x_j, n) \) powinno być nietrywialnym dzielnikiem \( n \), ponieważ wykonaliśmy zbyt mało kroków, żeby \( n \mid (x_i - x_j \). Jeśli powstanie cykl \( \mod \ p \) o długości \( s \), to taka sytuacja będzie się powtarzać dla wszystkich \( x_i,\; x_{i+s} \). Nie można jednak co krok sprawdzać dla wszystkich \( x_i,\; i < j \) przystawania do \( x_j \). Zamiast tego, żeby wykryć długość \( s \) cyklu, wykorzystuje się metodę Floyda lub Brenta.

Podsumowując, tak wygląda algorytm, który dla zadanej liczby złożonej \( n \) znajduje jakiś jej nietrywialny dzielnik.
\begin{greyframe}
    Algorytm rho:
    \begin{enumerate}
        \item Jeśli \( 2 \mid n \), zwróć 2.
        \item Przypisz \( x = x_0, y = x_0, d = 1 \).
        \item Dopóki \( d == 1 \):
        \begin{enumerate}
            \item Oblicz \( x = f(x) \mod \ n \) oraz \( y = f(f(y)) \mod \ n \).
            \item Oblicz \( d = \gcd(x-y, n) \).
        \end{enumerate}
        \item Jeśli \( d \neq n \), zwróć \( d \).
        \item Powtórz procedurę od kroku 2, wybierając nowe \( x_0 \) oraz \( f \).
    \end{enumerate}
\end{greyframe}

\textbf{Złożoność:} \\
Zapętlenie oraz wyłapanie tego wymaga w oczekiwaniu około \( \sqrt{p} + s \leq 2\sqrt{p} = \bigO(\sqrt[4]{n}) \) kroków. Jeśli algorytm zakończy się powodzeniem, po tylu krokach \( \gcd(x_{2k} - x_k, n \) będzie dzielnikiem \( n \).
Są jednak dwa scenariusze niepowodzenia:
\begin{itemize}
    \item Wyrazy ciągu mogą nie powtórzyć się wystarczająco szybko - przerywamy procedurę po \( 5\sqrt[4]{n} \) krokach.
    \item Ciąg zapętlił się \( \mod \ p \) oraz \( \mod \ n \), czyli \( \gcd(x_{2k} - x_k, n) = n \) - od razu przerywamy algorytm.
\end{itemize}


\subsection{Metoda Floyda}
Pomysł polega na tym, żeby w każdym kroku sprawdzać tylko wartość \( \gcd(x_{2k} - x_k, n) \), ponieważ te dwa wyrazy będą przystawać do siebie \( \mod \ p \), kiedy \( k \) będzie wielokrotnością \( s \). Ciąg \( x_{2k} \) można zdefiniować jako \( y_0 = x_0,\; x_{2k} = y_k = f(f(y_{k-1})) \), unikając w ten sposób przechowywania wielu poprzednich wartości.


\subsection{Metoda Brenta}
Sprawdzamy, czy ciąg się zapętlił, wykonując kolejno \( K = 1, 2, 4, 8, \dots \) kroków. Jeśli w \( K \) krokach wyraz ciągu powtórzy się \( \mod \ p \), to udało się znaleźć wspólny dzielnik. Jeśli nie, to powtarzamy próbę dla kolejnego \( K \), zaczynając od miejsca, w którym skończyliśmy.

Ten wariant ma trochę lepszą stałą niż metoda Floyda.