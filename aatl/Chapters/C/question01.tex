Jak wiadomo, każda liczba pierwsza \( p \) spełnia twierdzenie Fermata: \[ a^{p-1} = 1 \pmod{p} \] Byłby to dobry test pierwszości przy wylosowanej bazie \( a \), gdyby nie to, że liczba złożona też może go zdać dla pewnych szczególnych \( a \). Algorytm Millera-Rabina rozwiązuje, a przynajmniej minimalizuje ten problem. \\
Zanim algorytm, parę kluczowych spostrzeżeń. W grupie \( Z_p \) równanie \( x^2 = 1 \pmod{p} \) ma dokładnie dwa rozwiązania: \( 1 \), \( -1 = p - 1 \), ponieważ możemy rozłożyć lewą stronę równania: \[ (x-1) \cdot (x+1) = x^2 - 1 = 0 \pmod{p} \] Wynika z tego, że jeśli mamy \( a \), takie że \( a^{n-1} = 1 \pmod{n} \), \( a^{\frac{n-1}{2}} \neq \pm 1 \), to \( n \) jest liczbą złożoną. Jeśli \( a^{\frac{n-1}{2}} = -1 \pmod{n} \), to \( a \) nie nada się na świadka niepierwszości \( n \), w końcu jeśli \( a^{\frac{n-1}{2}} = 1 \pmod{n} \), to możemy powtórzyć sprawdzenie dla \( a^{\frac{n-1}{4}}\).

\begin{greyframe}
    Algorytm Millera-Rabina:
    \begin{enumerate}
        \item Znajdź \( s \) i nieparzyste \( k \), dla których \( n-1 = k \cdot 2^s \).
        \item Wylosuj \( a \in \{1, \dots, p - 1\} \).
        \item Oblicz \( (r_1, \dots, r_s ) = (a^k, a^{2k}, \dots, a^{2^{s-1}k}, a^{n-1}) \).
        \item Jeśli \( (r_1, \dots, r_s) = (1, \dots, 1) \), zwróć PIERWSZA.
        \item Jeśli \( (r_1, \dots, r_s) = (?, \dots, ?, -1, 1, \dots, 1) \), zwróć PIERWSZA.
        \item Zwróć ZŁOŻONA.
    \end{enumerate}
\end{greyframe}
Jeśli algorytm zwraca ZŁOŻONA, na pewno jest to poprawna odpowiedź. W przeciwnym wypadku prawdopodobieństwo pomyłki jest nie większe
niż \( \frac{1}{2} \), a w praktyce nawet mniej niż \( \frac{1}{4} \). Dowód opiera się na tym, że nieświadkowie to podgrupa \( \integer*_n \). Oczywiście można uzyskać jeszcze lepszą wiarygodność powtarzając test dla kilku \( a \), na przykład 12 kolejnych liczb pierwszych. \\
Złożoność jednego powtórzenia algorytmu to \( \bigO(\log^3(n)) \), ponieważ trzeba wykonać \( \bigO(\log(n)) \) mnożeń na liczbach o długości \( \log(n) \). Można zrobić to szybciej z FFT.