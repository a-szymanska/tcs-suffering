Trudno na ten moment poprawić złożoność czasową \( \Theta(\sqrt{\abs{G}}) \) algorytmu Baby-Step-Giant-Step, można jednak zmniejszyć użycie pamięci, co osiąga algorytm ,,ro'' Pollarda, który korzysta ze stałej pamięci.

Główny pomysł polega na tym, żeby wygenerować dużo elementów postaci \( a^{\alpha_i} \cdot b^{\beta_i} \), dla różnych \( \alpha_i \) oraz \( \beta_i \), aż wystąpi kolizja.

Krótkie uzasadnienie: Jeśli \( a^{\alpha_i} \cdot b^{\beta_i} = a^{\alpha_j} \cdot b^{\beta_j} \), to \( a^{\alpha_i - \alpha_j} = b^{\beta_j - \beta_i} \). Wystarczy wtedy znaleźć \( \beta* = (\beta_j - \beta_i)^{-1} \) modulo \( \abs{G} \) i otrzymamy \( a^{\beta* \cdot (\alpha_i - \alpha_j)} = b \).

Ciąg \( (\alpha_i, \beta_i) \) generujemy, losując wartości początkowe \( (\alpha_0, \beta_0) \), a następne obliczając za pomocą pewnej deterministycznej funkcji \( f \), która zapewni pseudolosowść wyników:
\[ (\alpha_{i+1}, \beta_{i+1}) = f(\alpha_i, \beta_i) \]
Jeśli w jakimś momencie \( (\alpha_i, \beta_i) = \alpha_j, \beta_j) \), to tak już zostanie, czyli ciąg wpada w pętlę literki ,,ro''. Analogicznie jak w algorytmie do faktoryzacji zpomocą metody Floyda można zdefiniować drugi ciąg:
\[ (\alpha'_{i+1}, \beta'_{i+1}) = f(f(\alpha'_i, \beta'_i) \]
i w każdym kroku sprawdzać, czy \( (\alpha_i, \beta_i) = (\alpha'_i, \beta'_i) \). Gdyby ciągi były losowe, kolizja powinna wystąpić w oczekiwaniu po \( \sqrt{G} \) krokach.

Pozostaje uszczegółowić wybór funkcji \( f \). Powinna ona rozrzucać wartości ciągu możliwie przypadkowo wśród elementów \( G \). Technika stosowana w praktyce jest następująca:
\begin{itemize}
    \item Wybieramy małą liczbę naturalną \( n \), na przykład \( n = 20 \).
    \item Wybieramy funkcję haszującą \( h \), która parze liczb całkowitych \( (\alpha, \beta) \) przyporządkowuje liczbę ze zbioru \( \{1, 2, \dots, n\} \).
    \item Losujemy liczby naturalne \( x_1, \dots, x_n \) oraz \( y_1, \dots, y_n \).
    \item Definiujemy \( f(\alpha, \beta) = (\alpha + x_s, \beta + y_s) \), gdzie \( s = h(\alpha, \beta) \).
\end{itemize}

Algorytm ,,ro'' działa w oczekiwanym czasie \( \bigO\left(\sqrt{\abs{G}}\right) \) oraz stałej pamięci.